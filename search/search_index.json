{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tridev","text":"<p>Three principal deities in Hinduism is known as the Trimurti,\u201c\u0924\u094d\u0930\u093f\u092e\u0942\u0930\u094d\u0924\u093f\u201d Each component of the term is broken down as follows: \u0924\u094d\u0930\u093f (tri) - meaning \u201cthree\u201d \u092e\u0942\u0930\u094d\u0924\u093f (murti) - meaning \u201cform\u201d or \u201cmanifestation\u201d Together, \u201cTrimurti\u201d (Tridev) signifies the three forms or manifestations, referring to in Hindu theology as Brahma (the Source/Creator), Vishnu (the Preserver/Indwelling-life) and Shiva (the Transformer Destroyer/Creator).</p> <p>Tridev is a GitOps utility that creates ephemeral environments based on manifests in this repository.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>The first, and arguably most important, configuration is the name of the environment. This is derived from the name of your <code>yaml</code> file.  Names can be lowercase alphanumeric and include hyphens, but no other characters are allowed and names must start with a letter and be no more than 40 chars.</p> <p>The rest of the <code>tridev</code> configuration is presented below:</p> <pre><code>## @param clusterSetup [default: automatic]  determines how cluster is maintained.  Supply \"manual\" if cluster is already created.\n## DO NOT CHANGE!  Set to manual for Shanghaied setups\n##\n# clusterSetup: automatic\n\n## @param projectID [default: platform-cloud-engineering]  GCP project ID to create the cluster and Crossplane-managed resources\n##\n# projectID: platform-cloud-engineering\n\n## @param releaseChannel [default: regular]  Release channel used to create the GKE autopilot cluster\n## Allowed values: rapid, regular, or stable.  This can be modified later.\n##\n# releaseChannel: regular\n\n## @param lifecycle [default: * * * * *]  Cron expression to establish lifecycle of GKE autopilot cluster\n## Cron expression will always ignore minutes argument, it only considers hour and above\n## arguments. Every hour at minute 00 a scheduled job will evaluate all the environments\n## lifecycle expressions; environments whose lifecycle is out of range will be automatically\n## destroyed (if cluster exists) and for those environments whose cluster hasn't been created\n## and they are inside the date-time range expressed in their lifecycle, those will be\n## automatically created.\n## CAUTION: Every environment using a lifecycle expression different from the default\n## value \"* * * * *\", which allows an environment to be running 24/7, as soon as they\n## are outside of time range, they will be destroyed along with every workload and disks\n## that were used inside of them.\n# lifecycle: * * * * *\n\n## @param releases [array]  List of Helm chart releases to install into cluster\n##\n## name: \"Required: name of the chart.\"\n## version: \"Required: version of the chart.\"\n## alias: \"Optional: Alias name for a chart.  Helpful when installing same chart multiple times.\"\n## namespace: \"Optional: namespace to install the chart (default: Default).\"\n## repo: \"Optional: Artifactory repo URL (default: https://dexcom.jfrog.io/artifactory/dexcom-helm-dev-local).\"\n## wave: \"Optional (integer): Argo sync wave to install the chart (default: 0).\"\n## values: | # optional override values file as a string.\n##     example:\n##       replicas: 2\n## remoteValues: []  # list of remote values files as a URL\nreleases: []\n</code></pre> <p>Upon merging into <code>dev</code> the above <code>tridev</code> manifest will be converted into individual Argo <code>application</code> manifests under the <code>argo</code> directory (folder will be named by the same as your environment, i.e. <code>tridev</code> file name).  The default branch for the Argo files will be deploy. This branch has few protections and the generated Argo files can be updated at will, though keep in mind that changes made directly in that branch aren't guaranteed to be preserved.</p> <p>A GKE cluster will likewise be created, again named after the specified <code>env</code> and each release will be deployed to that cluster.</p> <p>Subsequent updates can be made to the <code>tridev</code> manifest and these will likewise be pushed to the GKE cluster though no additional cluster will be created.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>There's a sample demo environment provided in the <code>tridev</code> directory.  The demo includes many of the base tooling most clusters need including:</p> <ul> <li>Nginx Ingress</li> <li>Cert Manager</li> <li>External DNS</li> </ul> <p>Copy this file and give it a unique name for your environment.  Create a PR and, upon merge, the Github Action will run to generate a new cluster in the platform-cloud-engineering project.</p>"},{"location":"charts/cloudeng-deployment/","title":"cloudeng-deployment","text":"<p>This template is intended to create a <code>deployment</code> workload along with other K8s resources like a service account, service, horizontal pod autoscaler, etc.</p>"},{"location":"charts/cloudeng-deployment/#parameters","title":"Parameters","text":""},{"location":"charts/cloudeng-deployment/#global","title":"Global","text":"<p>The global section is a good place to expose common values that require overrides between environments, e.g. featureFlagEnabled=false. The only required value is the environment name.</p> Name Description Value <code>global.env</code> the environment name <code>\"\"</code> <code>global.projectID</code> the GCP project ID, required when setting up GCP service accounts <code>\"\"</code> <code>global.enableDatadogJavaAPM</code> enable Datadog Java APM <code>false</code>"},{"location":"charts/cloudeng-deployment/#deployment-parameters","title":"Deployment Parameters","text":"<p>The following parameters are common in orchestrating a deployment, including image version, resource requirements, service accts, and services/ingress.</p> Name Description Value <code>env</code> the environment name <code>{{ .Values.global.env }}</code> <code>image.repository</code> deployment's image repository (full path minus the tag) <code>\"\"</code> <code>image.tag</code> deployment's image tag <code>\"\"</code> <code>image.pullPolicy</code> deployment's image pull policy <code>IfNotPresent</code> <code>imagePullSecrets</code> credentials for <code>cluster-artifactory-creds</code> <code>nameOverride</code> overrides the name of the deployment <code>\"\"</code> <code>fullnameOverride</code> overrides the full name of the deployment <code>\"\"</code> <code>podLabels</code> additional labels as needed (note: default selector labels are automatically added) <code>{}</code> <code>podAnnotations</code> additional annotations as needed <code>{}</code> <code>initContainers</code> add additional init containers to the deployment pods <code>[]</code> <code>sidecars</code> add additional sidecar containers to the deployment pods <code>[]</code> <code>command</code> command for running the container (ignored if not set). <code>[]</code> <code>args</code> args for running the container (ignored if not set). <code>[]</code> <code>safeToEvict</code> whether or not the pod is safe to evict <code>true</code> <code>requests_cpu</code> The amount of CPU to request for the container <code>100m</code> <code>requests_memory</code> the amount of memory to request for the container <code>128Mi</code> <code>limits_cpu</code> the amount of CPU to limit for the container <code>\"\"</code> <code>limits_memory</code> the amount of memory to limit for the container <code>\"\"</code> <code>extraResourcesRequests</code> extra resources requests for the container other than CPU and Memory (ignored if not set). <code>{}</code> <code>extraResourcesLimits</code> extra resources limits for the container other than CPU and Memory <code>{}</code> <code>podSecurityContext</code> security context for the container <code>{}</code> <code>securityContext</code> security context for the container <code>{}</code> <code>enableDatadogJavaAPM</code> enable Datadog Java APM <code>false</code> <code>linkerd.enabled</code> enable Linkerd for deployment <code>false</code> <code>linkerd.inject</code> enable Linkerd annotation to enable a service mesh mode.  Accepted values: enabled, disabled, and ingress <code>enabled</code> <code>linkerd.configAnnotations</code> configuration annotations from Linkerd to inject in deployment pods <code>{}</code> <code>replicaCount</code> number of replicas to run (ignored if autoscaling.enabled is true) <code>1</code> <code>autoscaling</code> configuration for autoscaling the deployment <code>{}</code> <code>envVars</code> environment variables to set in the container <code>[]</code> <code>envVarsCM</code> configmaps to mount as environment variables <code>[]</code> <code>envVarsSecret</code> secrets to mount as environment variables <code>[]</code> <code>configMapMounts</code> configmaps to mount as directories or files <code>[]</code> <code>secretMounts</code> secrets to mount as directories or files <code>[]</code> <code>existingClaims</code> existing persistent volume claims to mount as directories <code>[]</code> <code>serviceAccount.projectID</code> GCP project where GCP SA will be bound if set to true <code>{{ .Values.global.projectID }}</code> <code>serviceAccount.create</code> create a service account <code>true</code> <code>serviceAccount.annotations</code> additional GKE SA annotations to add <code>{}</code> <code>serviceAccount.name</code> name of the service account to use <code>\"\"</code> <code>serviceAccount.gcp.create</code> create a GCP service account <code>false</code> <code>serviceAccount.gcp.bind</code> bind the GCP service account to the GKE service account <code>false</code> <code>serviceAccount.gcp.name</code> name of the GCP service account to use (formatted {{ .Values.global.env }}-{{ .Values.gcp.name }}) <code>\"\"</code> <code>serviceAccount.gcp.fullnameOverride</code> exact name of the GCP service account to use <code>\"\"</code> <code>serviceAccount.gcp.projectID</code> GCP project where GCP SA will be created if set to true <code>{{ .Values.global.projectID }}</code> <code>livenessProbe</code> liveness probe for the container (will restart the container if it fails) <code>{}</code> <code>readinessProbe</code> readiness probe for the container (will mark the container as ready if it succeeds) <code>{}</code> <code>startupProbe</code> startup probe for the container <code>{}</code> <code>lifecycle</code> lifecycle handlers for the container <code>{}</code> <code>service.type</code> type of service to create <code>ClusterIP</code> <code>service.ports</code> ports to expose <code>[]</code> <code>ports</code> ports to expose <code>[]</code> <code>ingress.enabled</code> enable ingress for the deployment <code>false</code> <code>ingress.canaryWeight</code> percentage of traffic (0-100) to send to this deployment as canary (-1 for disabled) <code>-1</code> <code>ingress.className</code> ingress class to use <code>\"nginx\"</code> <code>ingress.annotations</code> additional annotations to add to the ingress <code>{}</code> <code>ingress.hosts</code> hosts to add to the ingress <code>[]</code> <code>topologySpreadConstraints</code> topology spread constraints for the deployment <code>[]</code> <code>nodeSelector</code> node selector for the deployment <code>{}</code> <code>tolerations</code> tolerations for the deployment <code>{}</code> <code>affinity</code> affinity for the deployment <code>{}</code> <code>enableReloader</code> adds Reloader annotation for deployment. <code>true</code>"},{"location":"faq/faq/","title":"FAQ","text":""},{"location":"faq/faq/#how-do-i-document-my-chart-in-order-to-auto-generate-readmes","title":"How do I document my chart in order to auto-generate READMEs","text":"<p>TBD</p>"},{"location":"helm/building-helm-chart/","title":"Building a Helm Chart","text":""},{"location":"helm/building-helm-chart/#getting-started","title":"Getting Started","text":"<p>To get started it is recommended to use the Ditto tool to build your Helm chart.  Ditto can be used to create a Helm chart based on a live deployment or build a starting chart that leverages existing libraries and templates.</p>"},{"location":"helm/building-helm-chart/#setting-up-ditto","title":"Setting up Ditto","text":"<p>TBD</p>"},{"location":"helm/tips-and-tricks/","title":"Tips and Tricks","text":""},{"location":"helm/tips-and-tricks/#writing-charts","title":"Writing Charts","text":""},{"location":"helm/tips-and-tricks/#naming-resources","title":"Naming Resources","text":"<p>TBD</p>"},{"location":"helm/tips-and-tricks/#using-subcharts","title":"Using Subcharts","text":"<p>TBD</p>"},{"location":"helm/tips-and-tricks/#documentation","title":"Documentation","text":"<p>TBD</p>"},{"location":"helm/tips-and-tricks/#using-the-helm-cli","title":"Using the Helm CLI","text":""},{"location":"helm/tips-and-tricks/#finding-charts-in-artifactory","title":"Finding Charts in Artifactory","text":"<p>TBD</p>"},{"location":"helm/tips-and-tricks/#displaying-charts-default-values","title":"Displaying Chart's Default Values","text":"<p>TBD</p>"},{"location":"helm/tips-and-tricks/#displaying-charts-overrides","title":"Displaying Chart's Overrides","text":"<p>TBD</p>"},{"location":"helm/tips-and-tricks/#rolling-back-a-change","title":"Rolling Back a Change","text":"<p>TBD</p>"},{"location":"quickstart/quickstart/","title":"Quickstart","text":""},{"location":"quickstart/quickstart/#configuration","title":"Configuration","text":"<p>The first, and arguably most important, configuration is the name of the environment. This is derived from the name of your <code>yaml</code> file.  Names can be lowercase alphanumeric and include hyphens, but no other characters are allowed and names must start with a letter and be no more than 40 chars.</p> <p>The rest of the <code>tridev</code> configuration is presented below:</p> <pre><code>## @param clusterSetup [default: automatic]  determines how cluster is maintained.  Supply \"manual\" if cluster is already created.\n## DO NOT CHANGE!  Set to manual for Shanghaied setups\n##\n# clusterSetup: automatic\n\n## @param projectID [default: platform-cloud-engineering]  GCP project ID to create the cluster and Crossplane-managed resources\n##\n# projectID: platform-cloud-engineering\n\n## @param releaseChannel [default: regular]  Release channel used to create the GKE autopilot cluster\n## Allowed values: rapid, regular, or stable.  This can be modified later.\n##\n# releaseChannel: regular\n\n## @param lifecycle [default: * * * * *]  Cron expression to establish lifecycle of GKE autopilot cluster\n## Cron expression will always ignore minutes argument, it only considers hour and above\n## arguments. Every hour at minute 00 a scheduled job will evaluate all the environments\n## lifecycle expressions; environments whose lifecycle is out of range will be automatically\n## destroyed (if cluster exists) and for those environments whose cluster hasn't been created\n## and they are inside the date-time range expressed in their lifecycle, those will be\n## automatically created.\n## CAUTION: Every environment using a lifecycle expression different from the default\n## value \"* * * * *\", which allows an environment to be running 24/7, as soon as they\n## are outside of time range, they will be destroyed along with every workload and disks\n## that were used inside of them.\n# lifecycle: * * * * *\n\n## @param releases [array]  List of Helm chart releases to install into cluster\n##\n## name: \"Required: name of the chart.\"\n## version: \"Required: version of the chart.\"\n## alias: \"Optional: Alias name for a chart.  Helpful when installing same chart multiple times.\"\n## namespace: \"Optional: namespace to install the chart (default: Default).\"\n## repo: \"Optional: Artifactory repo URL (default: https://dexcom.jfrog.io/artifactory/dexcom-helm-dev-local).\"\n## wave: \"Optional (integer): Argo sync wave to install the chart (default: 0).\"\n## values: | # optional override values file as a string.\n##     example:\n##       replicas: 2\n## remote\n\n## Building your first Tridev environment\n</code></pre> <p>To build your first environment it is recommended to grab an existing environment for reference.  The Cloud Engineering team typically has an environment with most of the Kuberenetes add-ons, e.g., <code>external-dns</code>, <code>nginx-ingress</code>, etc., preconfigured and this file can be referenced to start.</p> <ul> <li> <p>Step 1: Inside the <code>tridev</code> folder on the <code>dev</code> branch create/copy a new <code>yaml</code>   file.  Whatever you name the file will be the name of the environment and   cluster.</p> </li> <li> <p>Step 2: Add any Helm chart releases to the file under the <code>releases</code> section.   See Configuation for full instructions, but minimally you'll   need a chart name and version.  By default Tridev will pull from   <code>dexcom.jfrog.io/dexcom-helm-dev-virtual</code>, but this can be overriden by   supplying a <code>repo</code> override.</p> </li> </ul> <p><code>yaml   releases:     - name: my-chart       version: 1.0.1</code></p>"}]}